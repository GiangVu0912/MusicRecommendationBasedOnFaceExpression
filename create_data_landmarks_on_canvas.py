# -*- coding: utf-8 -*-
"""create_data_landmarks_on_canvas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rVxRdZ-zltY8gemugnbwmorCPKjJHwqj
"""

from google.colab import drive
drive.mount('/content/gdrive')

# Unzip
import zipfile
with zipfile.ZipFile("/content/gdrive/MyDrive/data.zip","r") as zip_ref:
    zip_ref.extractall()

!pip install mediapipe

import cv2
import os 
import mediapipe as mp 
import numpy as np 
import pickle

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import load_model
# from skimage import io

#setup
data_dir = 'data'
emotion_list = os.listdir(data_dir)
emotion_list.sort()
classes = {i:emotion_list[i] for i in range(len(emotion_list))}

classes.items()

mp_face_mesh = mp.solutions.face_mesh

mp_drawing = mp.solutions.drawing_utils
mp_drawing_styles = mp.solutions.drawing_styles

with mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1, min_detection_confidence=0.5) as face_mesh:
   for i, label in classes.items():
        path = os.path.join(data_dir, label)
        files = os.listdir(path)
        for file in files:
          img =  cv2.imread(os.path.join(path, file))
          print(img)
          results = face_mesh.process(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
          if not results.multi_face_landmarks:
            continue
          annotated_image = img.copy()
          canvas = np.zeros((annotated_image.shape[0],annotated_image.shape[1],3), dtype='uint8')
          canvas.fill(255)
          for face_landmarks in results.multi_face_landmarks:
            mp_drawing.draw_landmarks(
								image=canvas,
								landmark_list=face_landmarks,
								connections= mp_face_mesh.FACEMESH_TESSELATION,
								landmark_drawing_spec=None,
								connection_drawing_spec=mp_drawing_styles
								.get_default_face_mesh_tesselation_style())
            mp_drawing.draw_landmarks(
								image=canvas,
								landmark_list=face_landmarks,
								connections=mp_face_mesh.FACEMESH_CONTOURS,
								landmark_drawing_spec=None,
								connection_drawing_spec=mp_drawing_styles
								.get_default_face_mesh_contours_style())
            h, w, c = canvas.shape
            cx_min=  w
            cy_min = h
            cx_max = cy_max = 0
            for lm in face_landmarks.landmark:
              cx, cy = int(lm.x * w),int(lm.y * h)
              if cx < cx_min:
                cx_min = cx
              if cy < cy_min:
                cy_min = cy
              if cx > cx_max:
                cx_max = cx
              if cy > cy_max:
                cy_max = cy 
            new_path = os.path.join('data_extract', label)
            if os.path.exists(new_path):
              cv2.imwrite(os.path.join(new_path, file), canvas[max(cy_min,0):cy_max, max(cx_min,0):cx_max])
            else: 
              os.mkdir(new_path)
              cv2.imwrite(os.path.join(new_path, file),  canvas[max(cy_min,0):cy_max, max(cx_min,0):cx_max])

!zip -r /content/gdrive/MyDrive/data_extract.zip /content/data_extract